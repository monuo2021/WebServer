
日志系统
===============
日志系统采用单例模式，确保唯一实例；支持同步和异步日志，异步通过阻塞队列提高性能；日志按行数或日期分割，线程安全使用互斥锁。

该日志系统使用单例模式（Singleton Pattern）确保只有一个日志实例，方便集中管理日志。系统支持两种模式：

- 同步日志：直接将日志写入文件，简单但可能阻塞主线程。

- 异步日志：通过阻塞队列（`block_queue`）先存储日志，再由后台线程异步写入文件，减少I/O阻塞，提升性能，尤其适合高日志量场景。

### 单例模式与初始化

- 单例模式：Log 类使用静态局部变量实现单例模式（C++11后懒汉式无需加锁），确保整个程序只有一个日志实例。这符合日志系统的常见需求，便于集中管理，但也引入全局状态，可能在测试中带来挑战。

- 初始化：`init` 函数接受多个参数，包括文件名（file_name）、是否关闭日志（close_log）、日志缓冲区大小（默认8192字节）、分割行数（默认500万行）和最大队列大小（决定是否异步）。初始化时会根据日期生成带时间戳的日志文件名，如“2024_12_13_logname”，并检查文件是否成功打开。

###  同步日志

默认模式，直接将日志写入文件，使用 `std::ofstream` 确保 RAII 管理。优点是简单，缺点是I/O操作可能阻塞主线程，影响性能。

### 异步日志

- 若 `max_queue_size≥1`，启用异步模式，创建 `block_queue<std::string>` 存储日志，并启动后台线程（`flush_log_thread`）处理队列中的日志。后台线程通过 `detach` 运行，独立于主线程，减少I/O阻塞。

    - 好处：在高日志量场景下显著提升性能，适合多线程应用。
    - 潜在问题：若队列满，系统回退到同步模式，可能导致临时阻塞，需优化（如增加队列大小或丢弃低优先级日志）。

### 日志分割

- 系统支持按行数或日期分割日志：

    - 当日志行数达到 `m_split_lines` 或日期变化（通过 m_today 比较），关闭当前文件，生成新文件。
    - 新文件名格式如 “dir_name/YYYY_MM_DD_logname” 或追加后缀（如 “.N” 表示第N次分割）。

- 目的：保持日志文件大小可控，便于管理和分析，特别在长期运行的系统中。

### 日志级别与写入

- `write_log` 支持四种级别：调试（0）、信息（1）、警告（2）、错误（3），通过宏定义（如 `LOG_DEBUG`）调用。

- 使用可变参数（`va_list`）格式化日志，结合 `std::ostringstream` 生成带时间戳（如“YYYY-MM-DD HH:MM:SS.microseconds [level]: message”）的字符串。

- 线程安全通过 `std::mutex` 保护文件访问，确保多线程写入无竞争。

### 线程安全与资源管理

- 线程安全：`m_mutex` 保护文件操作和队列访问，防止数据竞争。异步模式下，队列操作也通过 `block_queue` 的内部锁保证线程安全。

- 资源管理：
        
    - `std::ofstream` 自动关闭文件，替代 C 风格的 `FILE*`。
    - `std::string m_buf` 替代 `char*` 缓冲区，自动管理内存。
    - `m_log_queue` 在析构函数中 `delete`，确保无内存泄漏。



### 可能面试题目

以下是基于日志系统的潜在面试问题，涵盖设计、性能、安全性和扩展性：

| **题目**                                      | **相关领域**         | **可能回答要点**                                                                 |
|-----------------------------------------------|----------------------|----------------------------------------------------------------------------------|
| 为什么使用单例模式？                          | 设计模式            | 确保唯一实例，集中管理日志；但可能引入全局状态，测试困难。                        |
| 异步日志如何工作？有什么好处？                 | 并发与性能          | 通过队列和后台线程减少I/O阻塞，适合高日志量；但队列满时回退同步可能阻塞主线程。    |
| 如何确保线程安全？                            | 线程安全            | 使用`std::mutex`保护文件和队列操作，防止数据竞争。                                |
| 日志分割的机制和目的是什么？                  | 文件管理            | 按行数或日期分割，保持文件可控，便于分析；如日期变化生成新文件。                  |
| 队列满时会怎样？                              | 边缘情况            | 回退同步模式写入，确保不丢日志，但可能阻塞主线程，需优化。                        |
| 内存管理如何实现？                            | 资源管理            | 使用`std::ofstream`和`std::string`，`block_queue`用`std::unique_ptr`，RAII保证。  |
| 单例模式的潜在缺点是什么？                    | 设计选择            | 引入全局状态，测试困难，扩展性受限；但日志系统通常接受此设计。                    |
| 如何支持基于文件大小的日志轮转？              | 扩展性              | 检查文件大小（如`std::filesystem::file_size`），超过阈值生成新文件。              |
| 如何使日志系统更高效或可扩展？                | 性能与设计          | 批量写入减少I/O，集成外部日志系统（如ELK）支持分布式日志。                        |
| 文件打开失败如何处理？                        | 错误处理            | 当前返回`false`，建议记录到stderr或备用日志，通知管理员。                        |
| 为什么`write_log`用可变参数？                 | C++特性             | 灵活格式化日志，`va_list`支持不同参数数，减少函数重载。                          |
| `std::ofstream`比`FILE*`的优点是什么？        | 现代C++             | RAII自动管理资源，安全无泄漏，接口更方便，集成C++流操作。                        |
| 异步模式如何保证日志顺序？                    | 并发与正确性        | 队列FIFO，单线程写入文件，顺序接近入队顺序，但多生产者可能有时间差。              |
| 如何测试同步和异步模式的正确性？              | 测试                | 单元测试验证顺序、队列满、文件打开失败、日志分割；多线程场景检查无竞争。          |
| 如何让日志系统运行时可配置？                  | 可扩展性            | 读取配置文件（如JSON）调整参数，或提供管理接口动态切换模式。                      |

