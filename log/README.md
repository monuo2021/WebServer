日志系统
===============
日志系统采用单例模式，确保唯一实例；支持同步和异步日志，异步通过阻塞队列提高性能；日志按行数或日期分割，线程安全使用互斥锁。

该日志系统使用单例模式（Singleton Pattern）确保只有一个日志实例，方便集中管理日志。系统支持两种模式：

- 同步日志：直接将日志写入文件，简单但可能阻塞主线程。

- 异步日志：通过阻塞队列（`block_queue`）先存储日志，再由后台线程异步写入文件，减少I/O阻塞，提升性能，尤其适合高日志量场景。

### block_queue 类

- 基于循环数组实现，支持 push 和 pop 操作。
- 使用 std::condition_variable 实现阻塞等待，pop 支持超时。
- 线程安全由 std::mutex 和 std::condition_variable 保证。

### 单例模式与初始化

- 单例模式：Log 类使用静态局部变量实现单例模式（C++11后懒汉式无需加锁），确保整个程序只有一个日志实例。这符合日志系统的常见需求，便于集中管理，但也引入全局状态，可能在测试中带来挑战。

- 初始化：`init` 函数接受多个参数，包括文件名（file_name）、是否关闭日志（close_log）、日志缓冲区大小（默认8192字节）、分割行数（默认500万行）和最大队列大小（决定是否异步）。初始化时会根据日期生成带时间戳的日志文件名，如“2024_12_13_logname”，并检查文件是否成功打开。

###  同步日志

默认模式，直接将日志写入文件，使用 `std::ofstream` 确保 RAII 管理。优点是简单，缺点是I/O操作可能阻塞主线程，影响性能。

### 异步日志

- 若 `max_queue_size≥1`，启用异步模式，创建 `block_queue<std::string>` 存储日志，并启动后台线程（`flush_log_thread`）处理队列中的日志。后台线程通过 `detach` 运行，独立于主线程，减少I/O阻塞。

- `async_write_log` 中使用使用带超时功能的 `pop` 进行批量处理（如收集 16 条日志后一次写入），减少频繁的 I/O 操作。
- 队列空时休眠 1ms，减少 CPU 使用。

### 日志分割

- 系统支持按行数或日期分割日志：

    - 当日志行数达到 `m_split_lines` 或日期变化（通过 m_today 比较），关闭当前文件，生成新文件。
    - 新文件名格式如 “dir_name/YYYY_MM_DD_logname” 或追加后缀（如 “.N” 表示第N次分割）。

- 目的：保持日志文件大小可控，便于管理和分析，特别在长期运行的系统中。

### 日志级别与写入

- `write_log` 支持四种级别：调试（0）、信息（1）、警告（2）、错误（3），通过宏定义（如 `LOG_DEBUG`）调用。

- 使用可变参数（`va_list`）格式化日志，结合 `std::ostringstream` 生成带时间戳（如“YYYY-MM-DD HH:MM:SS.microseconds [level]: message”）的字符串。

- 线程安全通过 `std::mutex` 保护文件访问，确保多线程写入无竞争。

### 线程安全与资源管理

- 线程安全：`m_mutex` 保护文件操作和队列访问，防止数据竞争。异步模式下，队列操作也通过 `block_queue` 的内部锁保证线程安全。

- 资源管理：
        
    - `std::ofstream` 自动关闭文件，替代 C 风格的 `FILE*`。
    - 使用 `std::unique_ptr<block_queue<std::string>>`，自动管理内存。

### 面试题及答案

以下是基于日志系统的潜在面试题及其答案，适合 C++ 开发者面试。

| **面试题**                                      | **答案**                                                                 |
|-------------------------------------------------|--------------------------------------------------------------------------|
| `block_queue` 的作用是什么？如何确保线程安全？   | 实现阻塞队列，生产者消费者模型。使用 `std::mutex` 和 `std::condition_variable` 保护共享资源，防止数据竞争。 |
| 异步日志的工作机制是什么？优缺点？               | 日志推入队列，后台线程写入文件。优点：提升性能；缺点：队列满时阻塞，退出可能丢失日志。 |
| 如何改进异步日志性能？                           | 批量处理日志，减少 I/O 操作；延迟刷新，降低同步写开销。                   |
| `std::unique_ptr` 为什么用于 `m_log_queue`？     | 自动管理内存，防止泄漏，符合 RAII 原则。                                 |
| 日志轮转的触发条件和实现？                       | 按日期变化或行数达到阈值触发，关闭旧文件，打开新文件，线程安全保护。       |
| 程序退出时如何避免异步日志丢失？                 | 添加退出标志，等待队列清空，确保所有日志写入。                           |
| `std::localtime` 线程安全问题如何解决？           | 使用 `std::localtime_r` 或在锁内调用，确保线程安全。                     |
| 日志文件无法打开如何处理？                       | `init` 返回 false，未处理轮转失败。建议添加错误日志或重试。               |
| 单例模式用于 Log 类的优缺点？                    | 优点：全局唯一，易访问；缺点：测试困难，隐式依赖。                        |
| 如何优化同步日志性能？                           | 减少 `flush` 频率，例如每 100 条日志刷新一次。                           |

---

### 关键引用
- [C++ Standard Library Reference - unique_ptr](https://en.cppreference.com/w/cpp/memory/unique_ptr)
- [C++ Filesystem Library - create_directories](https://en.cppreference.com/w/cpp/filesystem/create_directories)

